import std/[options, strformat]

import nimib, nimibook
import norm/sqlite

import tables

nbInit
nbUseNimibook

nbText: """
# Rows

## Insert Rows

To insert rows, use `insert` procs. There is a variant that takes a single model instance or a sequence of them.

Instances passed to `insert` must be mutable for Norm to be able to update their `id` fields.

In your inim session, run:
"""

nbCode:
  var
    userFoo = newUser("foo@foo.foo")
    userBar = newUser("bar@bar.bar")
    alice = newCustomer(some "Alice", userFoo)
    bob = newCustomer(some "Bob", userFoo)
    sam = newCustomer(some "Sam", userBar)
    aliceAndBob = [alice, bob]

nbText: """
Those are the objects we'll insert as rows in the database:
"""

nbCode:
  import std/with

  with dbConn:
    insert aliceAndBob
    insert userBar
    insert sam

nbText: &"""
Let's examine the queries:

    INSERT INTO "User" (email) VALUES(?) <- @['{userFoo.email}']
    INSERT INTO "Customer" (name, user) VALUES(?, ?) <- @['{get alice.name}', {userFoo.id}]
    INSERT INTO "Customer" (name, user) VALUES(?, ?) <- @['{get bob.name}', {userFoo.id}]
    INSERT INTO "User" (email) VALUES(?) <- @['{userBar.email}']
    INSERT INTO "Customer" (name, user) VALUES(?, ?) <- @['{get sam.name}', {userBar.id}]

When Norm attempts to insert `alice`, it detects that `userFoo` that it referenced in it has not been inserted yet, so there's no `id` to store as foreign key. So, Norm inserts `userFoo` automatically and then uses its new `id` (in this case, {userFoo.id}) as the foreign key value.

With `bob`, there's no need to do that since `userFoo` is already in the database.
"""


# Select Rows
# ------------
#
# To select a rows with Norm, you instantiate a model that serves as a container for the selected data and call `select`.
#
# One curious thing about `select` is that its result depends not only on the condition you pass but also on the container. If the container has `Model` fields that are not `None`, Norm will select the related rows in a single `JOIN` query giving you a fully populated model object. However, if the container has a `none Model` field, it is just ignored.
#
# In other words, Norm will automatically handle the "n+1" problem.
#
# Let's see how that works:
#
# .. code-block:: nim
#
#     nim> var customerBar = newCustomer()
#     nim> dbConn.select(customerBar, "User.email = ?", "bar@bar.bar")
#
# This is the SQL query generated by this `select` call:
#
# .. code-block::
#
#     SELECT "Customer".name, "User".email, "User".id, "Customer".id
#     FROM "Customer" JOIN "User" ON "Customer".user = "User".id
#     WHERE User.email = ? <- ['bar@bar.bar']
#
# Let's examine how Norm populated `customerBar`:
#
# .. code-block:: nim
#
#     nim> echo customerBar[]
#     (name: Some("Sam"), user: ..., id: 3)
#     nim> echo customerBar.user[]
#     (email: "bar@bar.bar", id: 2)
#
# If you pass a sequence to `select`, you'll get many rows:
#
# .. code-block:: nim
#
#     nim> var customersFoo = @[newCustomer()]
#     nim> dbConn.select(customersFoo, "User.email = ?", "foo@foo.foo")
#
# The generated query is similar to the previous one, but the result is populated objects, not one:
#
# .. code-block:: nim
#
#     nim> for customer in customersFoo:
#     ....   echo customer[]
#     ....   echo customer.user[]
#     ....
#     (name: Some("Alice"), user: ..., id: 1)
#     (email: "foo@foo.foo", id: 1)
#     (name: Some("Bob"), user: ..., id: 2)
#     (email: "foo@foo.foo", id: 1)
#
#
# Count Rows
# ----------
#
# Selecting rows is expensive if many rows are fetched. Knowing the number of rows you have before doing the actual select is useful.
#
# To count the rows without fetching them, use `count`:
#
# .. code-block:: nim
#
#     nim> dbConn.count(Customer)
#     3
#
# To count only unique records, use `dist = true` in conjunction with the column name you want to check for uniqueness:
#
# .. code-block:: nim
#
#     nim> dbConn.count(Customer, "user", dist = true)
#     2
#
# You can also count rows matching condition:
#
# .. code-block:: nim
#
#     nim> dbConn.count(Customer, "*", dist = false, "name LIKE ?", "alice")
#     1
#
#
# Update Rows
# -----------
#
# To update a row, you just update the object and call `update` on it:
#
# .. code-block:: nim
#
#     nim> customerBar.name = some "Saaam"
#     nim> dbConn.update(customerBar)
#
# Since customer references a user, to update a customer, we also need to update its user. Norm handles that automatically by generating two queries:
#
# .. code-block::
#
#     UPDATE "User" SET email = ? WHERE id = 2 <- @['bar@bar.bar']
#     UPDATE "Customer" SET name = ?, user = ? WHERE id = 3 <- @['Saaam', 2]
#
# Updating rows in bulk is also possible:
#
# .. code-block:: nim
#
#     nim> for customer in customersFoo:
#     ....   customer.name = some (get(customer.name) & get(customer.name))
#     ....
#     nim> dbConn.update(customersFoo)
#
# For each object in `customersFoo`, a pair of queries are generated:
#
# .. code-block::
#
#     UPDATE "User" SET email = ? WHERE id = 1 <- @['foo@foo.foo']
#     UPDATE "Customer" SET name = ?, user = ? WHERE id = 1 <- @['AliceAlice', 1]
#     UPDATE "User" SET email = ? WHERE id = 1 <- @['foo@foo.foo']
#     UPDATE "Customer" SET name = ?, user = ? WHERE id = 2 <- @['BobBob', 1]
#
#
# Delete Rows
# -----------
#
# To delete a row, call `delete` on an object:
#
# .. code-block:: nim
#
#     nim> dbConn.delete(sam)
#
# That gives you, quite expectedly:
#
# .. code-block::
#
#     DELETE FROM "Customer" WHERE id = 3
#
# After deletion, the object becomes `nil`:
#
# .. code-block:: nim
#
#     nim> echo sam.isNil
#     true

nbSave
